---
layout: default
title:  "【阅板无数】（Intel x86 IoT系列）Intel Quark D2000 复活记"
tags: intel x86 zh-cn
---

<img src="http://icing.fun/img/post/2025/06/01/intel-quark-microcontroller-dev-kit-d2000-development-kit-with-intel-quark-d2000-microcontroller.png" alt="d2000" width="50%">

书接上回[【阅板无数】（Intel x86 IoT系列）Intel Arduino/Genuino 101 简单测评](https://icing.fun/2024/01/20/intel_genuino_101/)，我们讲到在2015年1月的时候，Intel “积极”拥抱开源硬件，推出了基于 Quark SoC 的 Arduino/Genuino 101 开发板。（其实英特尔在2013年就在英特尔论坛上推出了 Quark 系列的 32 位 x86 架构微控制器，很可惜在2019年1月英特尔宣布停止Quark系列产品的生产。）

## 前言

站在后人的角度看待英特尔在 IoT 领域的尝试，英特尔的确是有点“心有余而力不足”，倒也不至于全产品线沦落到“出师未捷身先死”的地步。其第一款产品是单核心 32 纳米 [X1000](https://www.intel.com/content/www/us/en/products/sku/79084/intel-quark-soc-x1000-16k-cache-400-mhz/specifications.html) SoC，应用在 Intel Galileo 开发板上。Intel Galileo 是基于 Intel x86 架构的 Arduino 认证开发板系列中的第一款，专为创客和教育社区而设计。

单凭这第一款产品可以看出来英特尔是想要积极拥抱开源硬件吗？如拥，用过这玩意儿的都知道，这个还要单独供电，核心非常烫手。（关于这款板子后续会有文章介绍，今天我们着重介绍 Quark D2000。）

这款代号为“薄荷峡谷（Mint Valley）”的 Intel Quark D2000 SoC 是英特尔在2015年Q3季度推出的产品，应用在 Intel Quark Microcontroller D2000 开发板上。它是英特尔在 IoT 领域的又一次尝试，旨在提供一个低功耗、低成本的解决方案，适用于物联网设备和嵌入式应用。

同时，Quark 系列也补全了英特尔在嵌入式微控制器领域的产品线。商用的 Xeon，消费级的 Core/Pentium/Celeron 系列，移动端的 Atom 系列，嵌入式的 Quark 系列。自此，英特尔补完了在微电子领域的产品线。<s>EE补完计划</s>

## 规格

| 产品名称 | Intel Quark D2000 Series |
| --- | --- |
| 代号 | Mint Valley |
| 垂直细分产线 | 嵌入式微控制器 |
| 核心架构 | 32 位 i586 |
| 核心数量 | 单核心 |
| 主频 | 32 MHz |
| L1 Cache | 0 KB |
| GPIO | SPI, I2C, GPIO, SPI, Comparators, ADC, PWM, DMA |
| UART | 2 个 UART |
| 封装 | LQFN40 |
| 描述 | 32位，单核单线程，Pentium ISA 兼容微控制器 |

详细规格可以参考[此处](https://www.intel.com/content/www/us/en/products/sku/91947/intel-quark-microcontroller-d2000/specifications.html)[<sup>1</sup>](#jump1)。

有意思的是，虽然写的是 Pentium ISA 兼容微控制器，但是它不支持 SIMD 或 x87 浮点。（玩过 8087 的都知道，8087 是 Intel 的第一个浮点协处理器。这玩意儿运行起来十分烫手，估计是因为功耗原因没加入 x87 浮点指令集。）

<img src="http://icing.fun/img/post/2025/06/01/IntelQuarkD2000-Fig1.webp" alt="d2000 fig" width="50%">

## 结语

不过这款产品还是非常能打的，站在软件开发的角度来看，英特尔其实是想把在 CPU 端的开发经验带到嵌入式领域。毕竟到了2015年，英特尔在 CPU 领域已经有了几十年的积累，x86 架构的微控制器可以让开发者更容易地使用现有的 x86 工具链和软件库，从而降低了开发门槛。

但是这样也有缺点，英特尔历史包袱太重，放不下庞大的PC/商用市场，或者说英特尔只是想在 Maker 社区和开源硬件社区赚一波快钱。这款产品从发布到生命周期结束，英特尔都没有好好对待。首先就是开发平台就只能使用 Intel System Studio for Microcontrollers，完全看不出英特尔的拥抱开源硬件的诚意（特别是 Arduino 授权，用 Arduino Uno 的 Pinout 但是不支持 Arduino IDE）。

反观 Nordic 和 Espressif 的产品，Nordic 的 nRF 系列和 Espressif 的 ESP 系列都提供了丰富的开源支持和社区资源，尤其是 Arduino，开发者可以轻松上手（Arduino 确实是为打破壁垒做出巨大贡献，让很多非电子专业的人们可以快速开发自己想要的东西）。而英特尔的 Quark D2000 开发板在这方面就显得将这些需求置若罔闻。

很重要的一点就是拥抱开源社区其实是在培养用户粘性，就好比 Espressif 的 ESP 系列产品，提供了丰富的开源支持和社区资源，尤其是 Arduino 生态系统。开发者可以轻松上手，快速开发出各种物联网应用。如果需要开发更复杂的应用，还可以使用 ESP-IDF（Espressif IoT Development Framework）进行更底层的开发。

也可能是因为时任英特尔 CEO 的布莱恩·科再奇（Brian Krzanich） <s>对下属十分热情</s> 对开源硬件的热情不够，导致英特尔在这方面的投入和支持力度不足。也可能是他在任期间，因为其战略决定，导致英特尔在研发10纳米制程芯片的进度上相比台积电及三星都要缓慢，导致市场占有率被竞争对手超微所蚕食。[<sup>2</sup>](#jump2) 

The Verge 还提到，英特尔虽然以 PC 和服务器而闻名，但其业务已被智能手机和云颠覆，而该公司似乎对人工智能和自动驾驶汽车的兴起毫无察觉。英特尔承诺推出智能耳机、英特尔驱动的智能手表、智能眼镜、英特尔电视服务、搭载英特尔芯片的无人机和自动驾驶汽车，但英特尔大约 85% 的收入仍然来自其服务器和 PC 工作。近年来，英特尔曾多次试图在 CES 上通过华丽的主题演讲重新定位自己，但这些努力没有说服力，也缺乏重点。

站在开源硬件的角度，英特尔同样不受待见。Arduino 社区从未接受 Curie，随着 Linux 驱动的 Raspberry Pi 越来越主导低端黑客板卡领域，Arduino 兼容性变得不再是必备功能。对于英特尔试图通过其 Curie 吸引的豪华智能手表供应商来说，这当然没有多大意义。

x86 社区也没有太多考虑 Quark。由于 Quark 最初仅宣布与 Pentium ISA 兼容，因此它的进展最初放缓了。当 Intel 添加 x86 兼容性时，为时已晚[<sup>3</sup>](#jump3)。

时任 LinkedIn 半导体销售和营销小组的主持人 Bill Giovino[<sup>4</sup>](#jump4) 评价 Intel Quark D2000 的文章中提到：*如今，似乎每家半导体公司都有用于物联网 （IoT） 的微控制器解决方案。我们看到了来自通常内核供应商的低功耗、高性能和高集成度微控制器的规格。但是，当英特尔宣布将重新进入微控制器业务，推出用于物联网的 32 位 x86 MCU 时，就像雷神拿起锤子再次参加比赛一样。*

> 注：英特尔最早的产品是3101 SRAM，英特尔第一款微控制器是基于哈佛架构的 Intel 8048/MCS-48（1976年），其衍生版本就有著名的 8051，也就是51单片机。

只可惜，在死神面前，雷神的锤子不堪一击，甚至连锤子都被捏的粉碎。

## <s>复活雷神的锤子</s> 

上面提到了，这款产品没有适配 Arduino IDE，所以我们需要使用 Intel System Studio for Microcontrollers 来编译和烧录程序。

可笑的是，英特尔在2019年1月宣布停止Quark系列产品的生产和支持，这意味着 Intel System Studio for Microcontrollers 也不再更新了。甚至 Intel System Studio for Microcontrollers 的下载链接都失效了。英特尔只保留了 Quark D2000 的数据手册、规格说明书和一些指南。

Quark D2000 Dev Platform的一些官方和三方链接我贴在此处：

1. [Intel® Quark™ Microcontroller Developer Kit D2000 – Getting Started for Windows* - Intel](https://www.intel.com/content/www/us/en/developer/articles/guide/intel-quark-microcontroller-developer-kit-d2000-getting-started-for-windows.html)
2. [Add a Button and LED to Your Intel® Quark™ Microcontroller Developer Kit D2000 - Intel](https://www.intel.com/content/www/us/en/developer/articles/technical/d2000-button-and-led.html#_Toc453769087)
3. [The QMSI Pin Name and Pin Map of Intel® Quark™ Microcontroller D2000 CRB - Intel](https://www.intel.cn/content/www/cn/zh/developer/articles/technical/the-qmsi-pin-name-and-pin-map-of-intel-quark-microcontroller-d2000-crb.html)
4. [Blink LED Test on Intel Quark D2000 Development Board - Autodesk Instructables](https://www.instructables.com/Blink-LED-Test-on-Intel-Quark-D2000-Development-Bo/)
5. [【X86 MCU】安裝Quark D2000開發環境 作者：何信昱 - MakerPro](https://web.archive.org/web/20170521234453/http://makerpro.cc/2017/05/the-introduction-of-quark-d2000/)
6. [Embedded System - Intel Quark - ShareTechnote](https://www.sharetechnote.com/html/Intel_Quark_SoftwareInstallation.html)
7. [The Quark D2000 Development Board: Moving Beyond “Hello World” - All About Circuits](https://www.allaboutcircuits.com/projects/the-quark-d2000-development-board-moving-beyond-hello-world/)

上面难得有点用的应该也就是第 3 个链接了。防止英特尔下架，我贴在我这里：

#### Pin Map 

<img src="http://icing.fun/img/post/2025/06/01/d2000-pinmap-681526.png" alt="pinmap" width="50%">

#### Pin Name

```c
/**
    * External Pad pin identifiers
   **/ 

    QM_PIN_ID_0,  /**< Pin id 0. */
    QM_PIN_ID_1,  /**< Pin id 1. */
    QM_PIN_ID_2,  /**< Pin id 2. */
    QM_PIN_ID_3,  /**< Pin id 3. */
    QM_PIN_ID_4,  /**< Pin id 4. */
    QM_PIN_ID_5,  /**< Pin id 5. */
    QM_PIN_ID_6,  /**< Pin id 6. */
    QM_PIN_ID_7,  /**< Pin id 7. */
    QM_PIN_ID_8,  /**< Pin id 8. */
    QM_PIN_ID_9,  /**< Pin id 9. */
    QM_PIN_ID_10, /**< Pin id 10. */
    QM_PIN_ID_11, /**< Pin id 11. */
    QM_PIN_ID_12, /**< Pin id 12. */
    QM_PIN_ID_13, /**< Pin id 13. */
    QM_PIN_ID_14, /**< Pin id 14. */
    QM_PIN_ID_15, /**< Pin id 15. */
    QM_PIN_ID_16, /**< Pin id 16. */
    QM_PIN_ID_17, /**< Pin id 17. */
    QM_PIN_ID_18, /**< Pin id 18. */
    QM_PIN_ID_19, /**< Pin id 19. */
    QM_PIN_ID_20, /**< Pin id 20. */
    QM_PIN_ID_21, /**< Pin id 21. */
    QM_PIN_ID_22, /**< Pin id 22. */
    QM_PIN_ID_23, /**< Pin id 23. */
    QM_PIN_ID_24, /**< Pin id 24. */

/**
 * Pin function type. (Mode 0 ~ Mode 3)
 */
    QM_PMUX_FN_0, /* Mode 0 */
    QM_PMUX_FN_1, /* Mode 1 */
    QM_PMUX_FN_2, /* Mode 2 */
    QM_PMUX_FN_3, /* Mode 3 */
```

#### Example

```c
/* Mux out STDOUT_UART tx/rx pins and enable input for rx. */
     qm_pmux_select(QM_PIN_ID_12, QM_PMUX_FN_2);
     qm_pmux_select(QM_PIN_ID_13, QM_PMUX_FN_2);
     qm_pmux_input_en(QM_PIN_ID_13, true);
```

那么你现在可能有疑问：IDE 都没有了，还有编译环境吗？有的，兄弟，有的。我们自己手动编译 IAMCU i586 的工具链。

### 手动编译 IAMCU i586 的工具链

英特尔十分难得地提供了 [The Intel Quark MCUs Software Stack](https://github.com/quark-mcu)。在 QMSI（Quark Microcontroller Software Interface）中，英特尔提供了一个名为 `qmsi` 的目录，其中包含了 Quark D2000 和 SE C1000 的驱动和库。具体参照[此链接](https://github.com/quark-mcu/qmsi/tree/d311fd6d16d8385c67b9e5a3310ed6f4f098b023)。在自述文件中提到：

*您必须首先设置 `IAMCU_TOOLCHAIN_DIR` 环境变量。 假设工具链被解压为 `$HOME/issm_2016/` 并且 您可以在 `$HOME/issm_2016/tools/compiler/gcc-ia/5.2.1/bin` 中找到 `i586-intel-elfiamcu-gcc` ……*

<s>这不禁让人兴奋起来</s> 敢情英特尔还是定制了一个 i586 的交叉编译工具链。理得佢咁多，先搞一个试试。

#### 环境

我用的是 [Ubuntu Server 18.04.6 LTS](https://releases.ubuntu.com/18.04/ubuntu-18.04.6-live-server-amd64.iso)，安装了以下依赖：

```bash
sudo apt update
sudo apt install build-essential git cmake gcc-multilib g++-multilib python3-pip
```

这环境属实是东雪莲它妈给东雪莲开门——罕见到家了。

接着需要获取 QMSI，这是 Intel 官方早期为 Quark D2000 提供的裸机驱动层，包含 GPIO、UART、RTC、I2C 等外设支持：

```bash
git clone https://github.com/quark-mcu/qmsi.git
cd qmsi
```

接着是编译和安装交叉编译工具链。Intel 官方推荐的工具链是 `i586-intel-elfiamcu-gcc`，不过因为你完全不可能下到原始安装包，所以我们需要手动编译。

```bash
export TARGET=i586-elf
export PREFIX=/opt/cross

# 下载 Binutils 和 GCC 源码
mkdir -p ~/quark-toolchain && cd ~/quark-toolchain
wget https://ftp.gnu.org/gnu/binutils/binutils-2.36.tar.gz
wget https://ftp.gnu.org/gnu/gcc/gcc-10.2.0/gcc-10.2.0.tar.gz

tar -xvf binutils-2.36.tar.gz
tar -xvf gcc-10.2.0.tar.gz
cd gcc-10.2.0
./contrib/download_prerequisites
cd ..

# 构建 binutils
mkdir build-binutils && cd build-binutils
../binutils-2.36/configure --target=$TARGET --prefix=$PREFIX --disable-nls
make -j$(nproc)
sudo make install
cd ..

# 构建 gcc（只要 C）
mkdir build-gcc && cd build-gcc
../gcc-10.2.0/configure --target=$TARGET --prefix=$PREFIX --disable-nls --enable-languages=c --without-headers
make all-gcc -j$(nproc)
make all-target-libgcc -j$(nproc)
sudo make install-gcc
sudo make install-target-libgcc
```

添加交叉编译工具链到 PATH：

```bash
export PATH=/opt/cross/bin:$PATH
```

检查是否安装成功：

```bash
i586-elf-gcc --version
```

现在环境才搭一半，工具链是“裸机”版本（newlib 或 newlib-nano 未安装或未连接），无法找到标准 C 头文件，如 `stdio.h`、`stdlib.h` 等。我们需要安装 newlib。

首先下载 newlib 源码：

```bash
git clone https://sourceware.org/git/newlib-cygwin.git
cd newlib-cygwin
```

构建并安装 newlib：

```bash
mkdir build && cd build
../configure --target=i586-elf --prefix=/opt/cross
make all -j$(nproc)
make install
# 如果安装失败，请尝试
sudo env "PATH=$PATH" make install
```

接着就是魔改 QMSI 的文件。定位到 `qmsi` 根目录下的 `base.mk` ，修改以下内容：

```makefile
### Tools
#PREFIX ?= arc-elf32
#TOOLCHAIN_DIR=$(ARCMCU_TOOLCHAIN_DIR)
#else
#PREFIX ?= i586-intel-elfiamcu
#TOOLCHAIN_DIR=$(IAMCU_TOOLCHAIN_DIR)
#endif

TOOLCHAIN_DIR := $(dir $(CROSS_COMPILE))
PREFIX := $(notdir $(CROSS_COMPILE))
CFLAGS += -Wno-error=implicit-fallthrough

.
.
.

ifeq ($(TARGET), sensor)
CFLAGS += -DQM_SENSOR
CFLAGS += -ffreestanding
CFLAGS += -mARCv2EM -mav2em -mno-sdata
LDFLAGS += -nostartfiles
LDLIBS += -lc -lgcc
else
#LDLIBS += -lc -lnosys -lsoftfp -lgcc
LDLIBS += -lc -lgcc
```

最后是编译，我们尝试编译一个 `blinky`：

```bash
unset IAMCU_TOOLCHAIN_DIR
cd ~/qmsi/examples/blinky
export CROSS_COMPILE=/opt/cross/bin/i586-elf
make TARGET=x86 SOC=quark_d2000 V=1
``` 

编译成功后会在 `release/quark_d2000/x86/bin/blinky.bin`。

> 注意：如果编译时候遇到编译器抛出 switch-case 函数错误 `error: this statement may fall through [-Werror=implicit-fallthrough=]` 的时候，请定位到报错行下方添加 `__attribute__((fallthrough));`。

#### 烧录

非常幸运的是，这个板子自带 `FTDI FT232HL` USB 转串口芯片，所以我们可以直接使用 `OpenOCD` 来烧录。

```bash
sudo apt install openocd
```

准备一下适用于 Quark D2000 的配置文件：

```bash
## quark_d2000.cfg
# Quark D2000 OpenOCD configuration file
# scan_chain
jtag newtap quark_d2000 lmt    -irlen 8  -irmask 0xff  -expected-id   0x38289013  -disable
jtag newtap quark_d2000 cltap  -irlen 8  -irmask 0xff  -expected-id   0x0e786013  -enable

# targets
target create lmt.cpu quark_d20xx -endian little -chain-position quark_d2000.lmt

lmt.cpu configure -event gdb-attach { halt }

# openocd puts tap at front of chain not end of chain
# to enable the lmt core we need to set bits [1:0] to 0x1
proc quark_d2000_lmt_tapenable {} {
        echo "Enabling lmt core tap"
        set val [ eval { irscan quark_d2000.cltap 0x11 ; drscan quark_d2000.cltap 12 0 } ]
        set val [ format 0x%x [ expr ( ( 0x$val & 0xffc ) | 0x01 ) ] ]
        irscan quark_d2000.cltap 0x11
        drscan quark_d2000.cltap 12 $val
        runtest 10
}

# to disable the lmt core we need to set bits [1:0] to 0x0
proc quark_d2000_lmt_tapdisable {} {
        echo "Disabling lmt core tap"
        set val [ eval { irscan quark_d2000.cltap 0x11 ; drscan quark_d2000.cltap 12 0 } ]
        set val [ format 0x%x [ expr ( 0x$val & 0xffc ) ] ]
        irscan quark_d2000.cltap 0x11
        drscan quark_d2000.cltap 12 $val
        runtest 10
}

proc quark_d2000_setup {} {
        jtag tapenable quark_d2000.lmt
}

jtag configure quark_d2000.lmt -event tap-enable "quark_d2000_lmt_tapenable"
jtag configure quark_d2000.lmt -event tap-disable "quark_d2000_lmt_tapdisable"

jtag configure quark_d2000.cltap -event setup "quark_d2000_setup"

#default frequency but this can be adjusted at runtime
adapter_khz 1000

reset_config trst_only

## Utility functions

# utility functions to delete OTPD and FLASH
proc del_flash0 {} { mww 0xB0100018 0x80 ; sleep 2000 ; mdw 0xB0100014 }
# utility function to delete OTPC, OTPD and FLASH
proc mass_erase {} {
 if { [ info exists ::QUARK_D2000_OTPC_DATA_WRITE_ENABLED ] &&
    [ expr $::QUARK_D2000_OTPC_DATA_WRITE_ENABLED ] } then {
        echo "Deleting  OTPC, OTPD and FLASH regions"
        mww 0xB0100018 0xC0 ; sleep 2000 ; mdw 0xB0100014
 } else {
        echo "No operation was performed"
        echo "mass_erase command deletes also the OTPC DATA protected region, but this behavior is disabled by default."
        echo "The following command will allow it: set QUARK_D2000_OTPC_DATA_WRITE_ENABLED 1"
        echo "To mass erase only the OTPD and FLASH regions use the 'del_flash0' command instead."
 }
}

# utility function to set SoC clock to 32MHz Si
proc clk32M { {jtag_khz 1000} } {
        # slow speed to make sure we can write mem
        adapter_khz 3
        # LMT halt
        irscan quark_d2000.cltap 0x70 ; drscan quark_d2000.cltap 8 0x1
        # set the SoC clock to the 32 MHz Silicon one
        mww 0xB0800008 0x2
        mww 0xB0800038 0x7
        mww 0xB0800038 0x87
        # set the JTAG clock to the desired one
        adapter_khz $jtag_khz
        # clear halt flag and reset the SoC
        irscan quark_d2000.cltap 0x70 ; drscan quark_d2000.cltap 8 0x0
        reset halt
}

# utility function to recover JTAG
# delay parameter is critical to stop the FW as soon as possible, the value
# varies from board to board, typical values are between 114 and 130 ms
proc jtag_recovery { {delay_ms 117} } {
        # disable polling, it'll just get in the way
        poll off

        # disable the lmt tap if not disabled already
        if { [jtag tapisenabled quark_d2000.lmt] } then { jtag tapdisable quark_d2000.lmt }

        # trigger a reset
        ftdi_set_signal nSRST 1
        sleep 500
        ftdi_set_signal nSRST 0

        # here we should wait 4 uS after reset is deasserted and reaches a logic 1
        # to have the tap available, but the reset needs some time to reach that
        # level as there are capacitances involved.
        # even if we switched the reset pin back to input we couldn't poll it fast
        # enough to get the right timing, so we need to measure experimentally the
        # rise time and determine the right openocd delay.
        #
        # granularity on the tcl command line in openocd is 1 ms.
        # if this is too coarse add a specific reset and delay command in C.
        sleep $delay_ms

        # re-initialize the jtag scanchain
        jtag arp_init

        # assert vpreq (it's cleared on reset)
        irscan quark_d2000.cltap 0x70 ; drscan quark_d2000.cltap 8 0x3

        # wait until we actually stop, we should actually poll vprdy but if we did
        # not stop after another 500 ms something went terribly wrong and polling
        # wouldn't help anyway
        sleep 500

        # re-initialize the jtag scanchain
        jtag arp_init

        # enable polling again
        poll on
}

# utility function to flash ROM
proc flash_rom { rom_file { address 0x0 } } {
        init
        echo "Setup clock"
        clk32M
        echo "Start flash"
        load_image $rom_file $address
        echo "Start verify"
        verify_image_offset $rom_file $address 0x150
        echo "Reset target"
        reset halt
        echo "All done"
}

## quark_d2000_onboard.cfg
## Quark D2000 Customer Reference Board

## Onboard FT232H Configuration
interface ftdi
ftdi_vid_pid 0x0403 0x6014
ftdi_channel 0

ftdi_layout_init 0x0000 0x030b
ftdi_layout_signal nTRST -data 0x0100 -noe 0x0100
ftdi_layout_signal nSRST -data 0x0200 -oe 0x0200

source [find ./quark_d2000.cfg]

# default frequency but this can be adjusted at runtime
adapter_khz 1000

reset_config trst_only
```

将两个配置文件保存为 `quark_d2000.cfg` 和 `quark_d2000_onboard.cfg`。尝试一下能否连接到设备：

```bash
ls /dev/ttyUSB*
openocd -f quark_d2000_onboard.cfg
```

如果一切正常，你应该能看到 OpenOCD 成功连接到 Quark D2000 开发板。

```bash
Open On-Chip Debugger 0.10.0
Licensed under GNU GPL v2
For bug reports, read
        http://openocd.org/doc/doxygen/bugs.html
Info : auto-selecting first available session transport "jtag". To override use 'transport select <transport>'.
adapter speed: 1000 kHz
trst_only separate trst_push_pull
adapter speed: 1000 kHz
trst_only separate trst_push_pull
Info : clock speed 1000 kHz
Info : JTAG tap: quark_d2000.cltap tap/device found: 0x0e786013 (mfg: 0x009 (Intel), part: 0xe786, ver: 0x0)
Enabling lmt core tap
Info : JTAG tap: quark_d2000.lmt enabled
```

也可以试试使用 `telnet` 连接到 OpenOCD：

```bash
telnet localhost 4444
```

尝试用 `halt` 命令暂停 CPU：

```bash
tomato@shit:~/qmsi/examples/blink$ telnet localhost 4444
Trying 127.0.0.1...
Connected to localhost.
Escape character is '^]'.
Open On-Chip Debugger
> halt
target halted due to debug-request at 0x0000ffff in real mode
```

如果一切正常，就可以使用 `gdb` 来烧录程序了。

```bash
sudo apt install gdb
```

在一个终端窗口中运行 OpenOCD：

```bash
openocd -f quark_d2000_onboard.cfg
```

此时创建一个新的终端会话并相应地设置环境变量。 然后使用以下命令启动 GDB 会话：

```bash
gdb
```

要连接到远程端口，请输入以下 GDB 命令：

```bash
(gdb) target remote :3333
```

使用以下命令将 ROM 和应用程序烧录到器件中：

```bash
(gdb) monitor load_image $PATH_TO_QM_BOOTLOADER/build/release/quark_d2000/rom/quark_d2000_rom.bin 0x0
(gdb) monitor load_image $PATH_TO_QMSI/examples/hello_world/release/quark_d2000/x86/bin/hello_world.bin 0x00180000
(gdb) monitor reset halt
```

到这里你以为一切都结束了？不，兄弟，这才刚刚开始。

这程序根本跑不起来。

最大的原因还是因为工具链的问题，我们自制的工具链虽然可以编译，但是没有办法让编译出来的文件在 Quark D2000 上运行。（后续原因我会慢慢找一下）

## 引用

1. <span id="jump1"><a href="https://www.intel.com/content/www/us/en/products/sku/91947/intel-quark-microcontroller-d2000/specifications.html">Intel® Quark™ Microcontroller D2000 - Intel</a></span>

2. <span id="jump2"><a href="https://web.archive.org/web/20201205135803/https://www.theverge.com/2018/6/22/17492184/intel-future-ceo-brian-krzanich-resignation-2018">Warren, Tom. Intel now faces a fight for its future. The Verge. 2018-06-22 [2020-11-26]. （原始内容存档于2020-12-05） </a></span>

3. <span id="jump3"><a href="https://linuxgizmos.com/who-killed-the-quark/">Who killed the Quark? by Eric Brown - LinuxGizmos.com</a></span>

4. <span id="jump4"><a href="https://www.mouser.com/applications/Intel-Quark-Internet-of-Things-MCU/">The Intel Quark®™ Microcontroller: Why an x86 MCU is The Right Stuff for The Internet of Things, By Bill Giovino - Mouser Electornics</a></span>